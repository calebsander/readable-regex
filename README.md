# readable-regex
A Node.js library for dynamically generating regular expressions in a readable fashion

[![npm Version](https://img.shields.io/npm/v/readable-regex.svg)](https://www.npmjs.com/package/readable-regex)
[![Build Status](https://travis-ci.org/calebsander/readable-regex.svg?branch=master)](https://travis-ci.org/calebsander/readable-regex)

## Concept
Regular expressions, while incredibly powerful, are nasty to look at. The use all sorts of special characters and they are rarely constructed in code from smaller, named components.
The idea of this library is to make it easier to read the components that go into a regular expression and to dynamically generate regular expressions using functions rather than string concatenation.

## Example
````javascript
const reg = require('readable-regex')
const SOME_DIGITS = reg.some(reg.DIGIT)
const DATE_CAPTURE = reg([
	reg.START,
	reg.capture(
		reg([
			reg.or(
				reg.capture(
					reg.some(
						reg.charIn(['a', 'z'], ['A', 'Z'])
					),
					'month-text'
				),
				reg.capture(
					SOME_DIGITS,
					'month-num'
				)
			),
			'-',
			reg.capture(
				SOME_DIGITS,
				'day'
			),
			'-',
			reg.capture(
				reg.times(reg.DIGIT, false, 2),
				'year'
			)
		]),
		'date'
	),
	reg.END
])
const match = reg.exec(DATE_CAPTURE, 'Jan-5-2017')
console.log(match.get('month-text')) //'Jan'
````

## RegExp construction methods (more are planned)
It is not advisable to pass in regular expressions not generated by this library because they are all assumed to be concatenatable due to being previously wrapped in non-capturing groups.

- `reg(Array<string|RegExp>|string|RegExp[, Array<Flag>|Flag flags])`: constructs a new regular expression by concatenating the component(s). If there is only one component, it doesn't need to be wrapped in an `Array`. Strings are interpreted as literal text and will be properly escaped (e.g. `'\n[abc]'` will become `/(?:\n\[abc\])/`). Flags are values of the object `reg.f` (global, case-insensitive, etc.).
- `reg.times(RegExp, boolean notGreedy, number min[, number max])`: matches the regular expression at least `min` times and at most `max` times, if a `max` is passed in. Making it not greedy will cause it to try to capture as few occurences as possible.
- `reg.any(RegExp[, boolean notGreedy])`: matches 0 or more occurences of the regular expression
- `reg.some(RegExp[, boolean notGreedy])`: matches 1 or more occurences of the regular expression
- `reg.maybe(RegExp[, boolean notGreedy])`: matches 0 or 1 occurences of the regular expression
- `reg.thisMany(RegExp, number times)`: matches `times` occurences of the regular expression
- `reg.capture(RegExp, string name)`: wraps the regular expression in a capturing group that can be referred to by `name`
- `reg.charIn(char|[char, char] ...chars)`: matches any of the specified characters. Individual characters specify a single character, whereas `Array`s of 2 of them specify a range of characters.
- `reg.charNotIn(char|[char, char] ...chars)`: matches any character besides the specified characters. Individual characters specify a single character, whereas `Array`s of 2 of them specify a range of characters.
- `reg.or(RegExp ...res)`: matches any instance of exactly one of the specified regular expressions

## Functions
- `reg.exec(RegExp, string)`: like `RegExp.prototype.match(string)` except the returned match object, if not `null`, has a `get` function which will take in the name of a capture group and return what was captured (see the example above)

## Constants
- `reg.ANY`: `.`
- `reg.DIGIT`: `\d`
- `reg.START`: `^`
- `reg.END`: `$`
- `reg.ALPHANUM`: `\w`
- `reg.NOT_ALPHANUM`: `\W`
- `reg.WHITESPACE`: `\s`
- `reg.NOT_WHITESPACE`: `\S`
- `reg.WORD_BOUND`: `\b`
- `reg.IN_WORD`: `\B`

## Flags
- `reg.f.GLOBAL`: the `g` flag
- `reg.f.IGNORE_CASE`: the `i` flag
- `reg.f.MULTILINE`: the `m` flag
- `reg.f.UNICODE`: the `u` flag
- `reg.f.STICKY`: the `y` flag
